Ideas for Experiments:

    1) Architecture Experiments
        - original SpatioTemporal model
        - Sequential model temporal->spatial
        - Sequential model spatial -> temporal
        - Vanilla Transformer
        
    2) Loss Experiments:
        - L2 loss on rotation matrix
        - geodesic loss
        - Quaternion loss -> https://towardsdatascience.com/better-rotation-representations-for-accurate-pose-estimation-e890a7e1317f
        - Euler loss -> https://towardsdatascience.com/better-rotation-representations-for-accurate-pose-estimation-e890a7e1317f
        - L2 loss on joint positions
        - maybe add some regularization (advesarial loss?)

    3) Joint representation experiments
        -> Already has been tested by the original work to some extend
        -> can be incorporated with the previous experiment
        - rotation matrix
        - quaternions
        - axis angles
        - joint positions
        - 6D rotation representation

    4) Positional encoding
        - original encoding
        - 
        - learned encoding
        - separate encoding for spatial and time domain
        
    4) Skeleton experiments
        - 26 joint skeleton -> full H3.6M
        - 21 joint skeleton -> H3.6M with dead joints removed
        - 19 joint skeleton -> same as AIS test set
        
    5) AIS test
        -> Gather knowledge and best models from previous experiments to build final model
        - Test with exact skeleton model as for the dataset
        - Optimize with given joint representation and limitations
        - Use larger skeleton model and interpolate somehow
    

Optional:
    1) Runtime Analysis
        - Optimize with TensorRT and run on embedded system
        - Test out how much we can look into the future while keeping real-time properties (20fps)
        - Test out different models with different predicition lengths
        - Compare results and analyse trade-off between real-time capability, prediction accuracy and prediction lengths
    2) Prediction length analysis
        - Evaluate the model on different prediction lengths (1,2,5,10 frames at a time)
        - Add predicition length token to dynamically change the prediction length of the model
        - Train with different spaced sequences
            -> Using different changes between timesteps might give the model a notion of speed that is used for prediction
    3) Classification head
        -> Add an additional classification token that classifies each action
        -> Classifying can help to predict future steps as it somewhat governs how the joints will move
        -> Add additional classification loss to the problem
        